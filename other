model = Sequential()
        # VVG block 1
        model.add(Conv2D(32, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same', input_shape=(32, 32, 3)))
        model.add(BatchNormalization())
        model.add(Conv2D(32, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same'))
        model.add(BatchNormalization())
        model.add(MaxPooling2D((2, 2)))
        model.add(Dropout(0.2))

        # VVG block 2
        model.add(Conv2D(64, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same'))
        model.add(BatchNormalization())
        model.add(Conv2D(64, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same'))
        model.add(BatchNormalization())
        model.add(MaxPooling2D((2, 2)))
        model.add(Dropout(0.3))

        # VVG block 3
        model.add(Conv2D(128, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same'))
        model.add(BatchNormalization())
        model.add(Conv2D(128, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same'))
        model.add(BatchNormalization())
        model.add(MaxPooling2D((2, 2)))
        model.add(Dropout(0.4))

        model.add(Flatten())
        model.add(Dense(128, activation='relu', kernel_initializer='he_uniform'))
        model.add(BatchNormalization())
        model.add(Dropout(0.5))
        model.add(Dense(10, activation='softmax'))

        # compile model
        opt = SGD(lr=0.001, momentum=0.9)
        model.compile(optimizer=opt, loss='categorical_crossentropy', metrics=['accuracy'])
        return model




            '''
    def generate_balanced_N_candidates(self):
        if (self.batch_num + 1)*self.N*self.C > len(self.all_combos): 
            self.batch_num = 0
            random.shuffle(self.all_combos)
        
        af_population_batch = self.all_combos[self.batch_num*self.N*self.C: (self.batch_num + 1)*self.N*self.C]

        self.population = []
        candidate_solution = []
        loss = 0.0
        accuracy = 0.0
        for i, key_combo in enumerate(af_population_batch):
            elementary_units_keys = key_combo
            elementary_units_functions = [self.unary_units[key_combo[0]], self.binary_units[key_combo[1]], self.unary_units[key_combo[2]]]
            core_unit = CORE_UNIT(elementary_units_keys, elementary_units_functions)
            candidate_solution.append(core_unit)
            if ((i + 1) % self.C == 0):
                self.population.append([candidate_solution, loss, accuracy])
                candidate_solution = []

        self.batch_num = self.batch_num + 1
        assert len(self.population) == self.N, "Error in population generation"